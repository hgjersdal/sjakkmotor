(declaim (optimize (speed 3) (debug 0) (safety 0)))
(in-package :sjakk)

(defun move-illegalp (board move whitep moves)
  (let ((castle-row (if whitep 0 7)))
    (or (king-capturep board moves)
	(and (chess-move-castle-long move)
	     (field-is-attackedp moves 3 castle-row))
	(and (chess-move-castle-short move)
	     (field-is-attackedp moves 5 castle-row)))))

(defun castle-check (castlings whitep move)
  (let ((can-castle (if whitep (can-castle-white castlings) (can-castle-black castlings)))
	(castle-row (if whitep 0 7)))
    (when (or (car can-castle) (cdr can-castle))
      (castle-still-legalp move can-castle castle-row))))

(defun negamaxit (board move depth alpha beta whitep castlings)
  (let ((scale (if whitep 1 -1))
	(can-castle (if whitep (can-castle-white castlings) (can-castle-white castlings))))
    (when (= depth 0)
      (return-from negamaxit (* scale (evaluate board))))
    (castle-check castlings (not whitep) move)
    (let ((moves (list-moves board can-castle whitep (chess-move-double-jump move)
			     (chess-move-old-col move)))
	  (castle-row (if whitep 0 7))
	  (best-move (make-chess-move))
	  (best-val 0))
      (when (move-illegalp board move (not whitep) moves)
       	(return-from negamaxit (values 32500 nil)))
      (loop for d from 1 to depth
	 with al = 0 do
	   (setf al alpha)
	   (setf best-val al)
	   (loop for m2 in moves
	      with val = 0 do
		(move-piece board m2 castle-row)
		(setf val (- (negamaxit board m2 (- d 1) (- beta) (- al) (not whitep)
					(copy-castle castlings))))
		(setf (chess-move-evaluation m2) val)
		(unmove-piece board m2 castle-row)
		(when (> val best-val)
		  (setf best-val val)
		  (setf best-move m2))
		(setf al (max al val))
		(when (>= al beta)
		  (return)))
	   (setf moves (sort moves (lambda (a b)
				     (> (chess-move-evaluation a)
					(chess-move-evaluation b))))))
      (values best-val best-move))))
